{"version":3,"file":"js/DynamicRoute.5563d83b1a138be419bf.js","mappings":"sIAkEYA,EAsCPC,E,iCC7FoE,OACK,OCGxDC,OAAO,WAiBFA,OAAO,SFkClC,SAAYF,GACV,kBACA,8BACA,UACA,gBACA,kBACA,sBACA,4BACA,sBACA,wBATF,CAAYA,IAAAA,EAAQ,KAsCpB,SAAKC,GACH,oBACA,sBAFF,CAAKA,IAAAA,EAAS,KGlCP,MAAME,EAAeC,GAA4C,uBAAXA,EAAEC,KCuB/D,IAAKC,EAqBOC,EC9GAC,GDyFZ,SAAKF,GACH,cACA,gBACA,sBACA,0BACA,oBALF,CAAKA,IAAAA,EAAoB,KAqBzB,SAAYC,GACV,UACA,gBACA,oBACA,oBACA,oBACA,sBACA,sBACA,0BACA,gCATF,CAAYA,IAAAA,EAAW,KC9GvB,SAAYC,GACV,sBACA,sBACA,kBAHF,CAAYA,IAAAA,EAAuB,KCID,gBAA4C,I,yDCA9E,MAAMC,EAAS,IACb,gBAAC,EAAAC,SAAQ,KACP,gBAAC,EAAAC,QAAO,OAaNC,EAAY,CAACC,GAAYC,KAAAA,EAAMC,MAAAA,MACnC,MAAO,CAAEC,GAAWH,EAASI,MAAM,KACnC,OAAO,IAAAC,WAAUL,EAAU,CAAEC,KAAAA,EAAMC,MAAAA,MAAY,IAAAG,WAAUL,EAAU,CAAEC,KAAM,IAAIE,IAAUF,IAAQC,MAAAA,KAoDnG,EAlDkD,EAAGI,SAAAA,MACnD,MAAOC,EAAWC,GAAgB,WAA2C,aACtEC,EAAeC,GAAoB,WAAuB,MAE3DC,GAAoB,IAAAC,eAAgC,GAiC1D,OAhCA,aAAgB,KACd,GAAIN,EAAU,CACZ,MAAQO,WAAYC,EAAS,WAAEC,GAC7BJ,EAAkBK,MAAK,EAAGH,WAAAA,KACpBI,MAAMC,QAAQL,EAAWZ,MACpBY,EAAWZ,KAAKkB,MAAMlB,GAASF,EAAUO,EAASN,SAAU,OAAF,wBAAOa,GAAU,CAAEZ,KAAAA,OAE/EF,EAAUO,EAASN,SAAUa,MAChC,GACJC,IACFJ,EAAiB,IAAUK,IAC3BP,GAAa,IACX,QAAW,KAAY,O,OAAA,E,OAAA,E,EAAA,YACrB,IACE,MAAO,CACLY,eAAgBN,EAAUO,cAAgBzB,GAE5C,MAAOL,GACP,MAAO,CACL6B,QAAS,IACP,gBAAC,EAAAvB,SAAQ,KACP,gBAACyB,EAAA,EAAU,CAACC,WAAY,oCAAoCR,kB,YAT/C,K,uRAkB5B,CAACT,EAAUK,IAGZ,2BAASa,UAAWf,GAAiB,IAClCF,EACC,gBAAC,WAAc,CAACkB,SAAU,MACxB,gBAAClB,EAAS,OAGZ,gBAACX,EAAM,S","sources":["webpack:///./src/poc-code/console-dynamic-plugin-sdk/src/api/common-types.ts","webpack:///./src/poc-code/console-plugin-sdk/src/api/pluginSubscriptionService.ts","webpack:///./src/poc-code/console-dynamic-plugin-sdk/src/coderefs/coderef-resolver.ts","webpack:///./src/poc-code/console-dynamic-plugin-sdk/src/extensions/pages.ts","webpack:///./src/poc-code/console-dynamic-plugin-sdk/src/extensions/console-types.ts","webpack:///./src/poc-code/console-dynamic-plugin-sdk/src/extensions/user-preferences.ts","webpack:///./src/poc-code/console-dynamic-plugin-sdk/src/perspective/perspective-context.ts","webpack:///./src/Routes/DynamicRoute/DynamicRoute.tsx"],"sourcesContent":["export { ResolvedExtension } from '../types';\n\n// Type for extension hook\nexport type ExtensionHook<T, R = any> = (options: R) => ExtensionHookResult<T>;\n\n// Type for extension hook result that returns [data, resolved, error]\nexport type ExtensionHookResult<T> = [T, boolean, any];\n\nexport type ExtensionK8sModel = {\n  group: string;\n  version: string;\n  kind: string;\n};\n\nexport type ExtensionK8sGroupModel = {\n  group: string;\n  version?: string;\n  kind?: string;\n};\n\nexport type ExtensionK8sGroupKindModel = {\n  group: string;\n  version?: string;\n  kind: string;\n};\n\nexport type ExtensionK8sKindVersionModel = {\n  group?: string;\n  version: string;\n  kind: string;\n};\n\nexport type K8sModel = {\n  abbr: string;\n  kind: string;\n  label: string;\n  labelKey?: string;\n  labelPlural: string;\n  labelPluralKey?: string;\n  plural: string;\n  propagationPolicy?: 'Foreground' | 'Background';\n\n  id?: string;\n  crd?: boolean;\n  apiVersion: string;\n  apiGroup?: string;\n  namespaced?: boolean;\n  selector?: Selector;\n  labels?: { [key: string]: string };\n  annotations?: { [key: string]: string };\n  verbs?: K8sVerb[];\n  shortNames?: string[];\n  badge?: BadgeType;\n  color?: string;\n\n  // Legacy option for supporing plural names in URL paths when `crd: true`.\n  // This should not be set for new models, but is needed to avoid breaking\n  // existing links as we transition to using the API group in URL paths.\n  legacyPluralURL?: boolean;\n};\n\n/**\n * @deprecated migrated to new type K8sModel, use K8sModel over K8sKind\n */\nexport type K8sKind = K8sModel;\n\nexport enum Operator {\n  Exists = 'Exists',\n  DoesNotExist = 'DoesNotExist',\n  In = 'In',\n  NotIn = 'NotIn',\n  Equals = 'Equals',\n  NotEqual = 'NotEqual',\n  GreaterThan = 'GreaterThan',\n  LessThan = 'LessThan',\n  NotEquals = 'NotEquals',\n}\n\nexport type MatchExpression = {\n  key: string;\n  operator: Operator | string;\n  values?: string[];\n  value?: string;\n};\n\nexport type MatchLabels = {\n  [key: string]: string;\n};\n\nexport type Selector = {\n  matchLabels?: MatchLabels;\n  matchExpressions?: MatchExpression[];\n};\n\ntype K8sVerb =\n  | 'create'\n  | 'get'\n  | 'list'\n  | 'update'\n  | 'patch'\n  | 'delete'\n  | 'deletecollection'\n  | 'watch';\n\nenum BadgeType {\n  DEV = 'Dev Preview',\n  TECH = 'Tech Preview',\n}\n\nexport const enum AlertStates {\n  Firing = 'firing',\n  NotFiring = 'not-firing',\n  Pending = 'pending',\n  Silenced = 'silenced',\n}\n\nexport const enum SilenceStates {\n  Active = 'active',\n  Expired = 'expired',\n  Pending = 'pending',\n}\n\nexport const enum AlertSeverity {\n  Critical = 'critical',\n  Info = 'info',\n  None = 'none',\n  Warning = 'warning',\n}\n\nexport const enum RuleStates {\n  Firing = 'firing',\n  Inactive = 'inactive',\n  Pending = 'pending',\n  Silenced = 'silenced',\n}\n\nexport type Silence = {\n  comment: string;\n  createdBy: string;\n  endsAt: string;\n  firingAlerts: Alert[];\n  id?: string;\n  matchers: { name: string; value: string; isRegex: boolean }[];\n  name?: string;\n  startsAt: string;\n  status?: { state: SilenceStates };\n  updatedAt?: string;\n};\n\nexport type PrometheusAlert = {\n  activeAt?: string;\n  annotations: PrometheusLabels;\n  labels: PrometheusLabels & {\n    alertname: string;\n    severity?: AlertSeverity | string;\n  };\n  state: AlertStates;\n  value?: number | string;\n};\n\nexport type Alert = PrometheusAlert & {\n  rule: Rule;\n  silencedBy?: Silence[];\n};\n\nexport type PrometheusRule = {\n  alerts: PrometheusAlert[];\n  annotations: PrometheusLabels;\n  duration: number;\n  labels: PrometheusLabels & {\n    severity?: string;\n  };\n  name: string;\n  query: string;\n  state: RuleStates;\n  type: string;\n};\n\nexport type Rule = PrometheusRule & {\n  id: string;\n  silencedBy?: Silence[];\n};\n\nexport type PrometheusLabels = { [key: string]: string };\nexport type PrometheusValue = [number, string];\n","import * as _ from 'lodash';\nimport { Store } from 'redux';\n// import { RootState } from '@console/internal/redux';\nimport { isExtensionInUse, PluginStore, DynamicPluginInfo } from '../store';\nimport { Extension, ExtensionTypeGuard, LoadedExtension } from '../typings';\n\nlet subscriptionServiceInitialized = false;\n\nconst extensionSubscriptions: ExtensionSubscription[] = [];\nconst dynamicPluginListeners: DynamicPluginListener[] = [];\n\nlet onExtensionSubscriptionAdded: (sub: ExtensionSubscription) => void = _.noop;\nlet onDynamicPluginListenerAdded: (listener: DynamicPluginListener) => void = _.noop;\n\nconst subscribe = <T>(sub: T, subList: T[], invokeListener: VoidFunction): VoidFunction => {\n  let isSubscribed = true;\n\n  subList.push(sub);\n  invokeListener();\n\n  return () => {\n    if (isSubscribed) {\n      isSubscribed = false;\n      subList.splice(subList.indexOf(sub), 1);\n    }\n  };\n};\n\nexport const initSubscriptionService = (pluginStore: PluginStore, reduxStore: Store/* <RootState> */) => {\n  if (subscriptionServiceInitialized) {\n    throw new Error('Subscription service is already initialized');\n  }\n\n  subscriptionServiceInitialized = true;\n\n  const getExtensionsInUse = () => pluginStore.getExtensionsInUse();\n  const getFlags = () => reduxStore.getState().FLAGS;\n\n  type FeatureFlags = ReturnType<typeof getFlags>;\n\n  const invokeExtensionListener = (\n    sub: ExtensionSubscription,\n    currentExtensions: Extension[],\n    currentFlags: FeatureFlags,\n  ) => {\n    // Narrow extensions according to type guards\n    const matchedExtensions = _.flatMap(sub.typeGuards.map((tg) => currentExtensions.filter(tg)));\n\n    // Gate matched extensions by relevant feature flags\n    const extensionsInUse = matchedExtensions.filter((e) =>\n      isExtensionInUse(e, currentFlags),\n    );\n\n    // Invoke listener only if the extension list has changed\n    if (!_.isEqual(extensionsInUse, sub.listenerLastArgs)) {\n      sub.listenerLastArgs = extensionsInUse;\n      sub.listener(extensionsInUse);\n    }\n  };\n\n  onExtensionSubscriptionAdded = (sub) => {\n    invokeExtensionListener(sub, getExtensionsInUse(), getFlags());\n  };\n\n  onDynamicPluginListenerAdded = (listener) => {\n    listener(pluginStore.getDynamicPluginInfo());\n  };\n\n  let lastExtensions: Extension[] = null;\n  let lastFlags: FeatureFlags = null;\n\n  const invokeAllExtensionListeners = () => {\n    if (extensionSubscriptions.length === 0) {\n      return;\n    }\n\n    const nextExtensions = getExtensionsInUse();\n    const nextFlags = getFlags();\n\n    if (_.isEqual(nextExtensions, lastExtensions) && nextFlags === lastFlags) {\n      return;\n    }\n\n    lastExtensions = nextExtensions;\n    lastFlags = nextFlags;\n\n    extensionSubscriptions.forEach((sub) => {\n      invokeExtensionListener(sub, nextExtensions, nextFlags);\n    });\n  };\n\n  let lastPluginEntries: DynamicPluginInfo[] = null;\n\n  const invokeAllDynamicPluginListeners = () => {\n    if (dynamicPluginListeners.length === 0) {\n      return;\n    }\n\n    const nextPluginEntries = pluginStore.getDynamicPluginInfo();\n\n    if (_.isEqual(nextPluginEntries, lastPluginEntries)) {\n      return;\n    }\n\n    lastPluginEntries = nextPluginEntries;\n\n    dynamicPluginListeners.forEach((listener) => {\n      listener(nextPluginEntries);\n    });\n  };\n\n  // Subscribe to changes in Console plugins and Redux\n  pluginStore.subscribe(invokeAllExtensionListeners);\n  pluginStore.subscribe(invokeAllDynamicPluginListeners);\n  reduxStore.subscribe(invokeAllExtensionListeners);\n\n  // Invoke listeners registered prior to initializing subscription service\n  invokeAllExtensionListeners();\n  invokeAllDynamicPluginListeners();\n};\n\n/**\n * Subscription based mechanism for consuming Console extensions.\n *\n * Provided listener will be invoked immediately to allow processing existing extensions.\n * It will also be invoked whenever the computed list of extension instances changes.\n *\n * _Tip: need to access extensions in a React component?_\n * - **Yes**\n *   - Functional components: use `useExtensions` hook.\n *   - Class components: use `withExtensions` higher-order component.\n * - **No**\n *   - Use `subscribeToExtensions` function.\n *\n * @param listener Listener invoked when the list of extension instances which are\n * currently in use, narrowed by the given type guard(s), changes.\n *\n * @param typeGuards Type guard(s) used to narrow the extension instances.\n *\n * @returns Function that unsubscribes the listener.\n */\nexport const subscribeToExtensions = <E extends Extension>(\n  listener: ExtensionListener<LoadedExtension<E>>,\n  ...typeGuards: ExtensionTypeGuard<E>[]\n) => {\n  if (typeGuards.length === 0) {\n    throw new Error('You must pass at least one type guard to subscribeToExtensions');\n  }\n\n  const sub: ExtensionSubscription<E> = { listener, typeGuards };\n\n  return subscribe<ExtensionSubscription>(sub, extensionSubscriptions, () => {\n    onExtensionSubscriptionAdded(sub);\n  });\n};\n\n/**\n * Subscribe to changes related to processing Console dynamic plugins.\n *\n * @param listener Listener invoked when the runtime status of a dynamic plugin changes.\n *\n * @returns Function that unsubscribes the listener.\n */\nexport const subscribeToDynamicPlugins = (listener: DynamicPluginListener) => {\n  return subscribe<DynamicPluginListener>(listener, dynamicPluginListeners, () => {\n    onDynamicPluginListenerAdded(listener);\n  });\n};\n\n/**\n * `ExtensionListener` adapter that computes the difference between the calls.\n */\nexport const extensionDiffListener = <E extends Extension>(\n  listener: (added: E[], removed: E[]) => void,\n): ExtensionListener<E> => {\n  let prevExtensions: E[] = [];\n\n  return (nextExtensions: E[]) => {\n    listener(\n      _.difference(nextExtensions, prevExtensions),\n      _.difference(prevExtensions, nextExtensions),\n    );\n\n    prevExtensions = nextExtensions;\n  };\n};\n\ntype ExtensionListener<E extends Extension> = (extensions: E[]) => void;\n\ntype ExtensionSubscription<E extends Extension = Extension> = {\n  listener: ExtensionListener<E>;\n  typeGuards: ExtensionTypeGuard<E>[];\n  listenerLastArgs?: E[];\n};\n\ntype DynamicPluginListener = (pluginInfoEntries: DynamicPluginInfo[]) => void;\n","/* eslint-disable no-console */\n\nimport * as _ from 'lodash';\nimport {\n  Extension,\n  RemoteEntryModule,\n  EncodedCodeRef,\n  CodeRef,\n  ResolvedCodeRefProperties,\n  ExtensionProperties,\n  UpdateExtensionProperties,\n} from '../types';\nimport { deepForOwn } from '../utils/object';\nimport { settleAllPromises } from '../utils/promise';\n\nconst codeRefSymbol = Symbol('CodeRef');\n\nexport const applyCodeRefSymbol = <T = any>(ref: CodeRef<T>) => {\n  ref[codeRefSymbol] = true;\n  return ref;\n};\n\nexport const isEncodedCodeRef = (obj): obj is EncodedCodeRef =>\n  _.isPlainObject(obj) &&\n  _.isEqual(Object.getOwnPropertyNames(obj), ['$codeRef']) &&\n  typeof (obj as EncodedCodeRef).$codeRef === 'string';\n\nexport const isExecutableCodeRef = (obj): obj is CodeRef =>\n  _.isFunction(obj) &&\n  _.isEqual(Object.getOwnPropertySymbols(obj), [codeRefSymbol]) &&\n  obj[codeRefSymbol] === true;\n\nconst codeRefErrorSymbol = Symbol('error');\nexport const isCodeRefError = (ref: CodeRef) => !!ref[codeRefErrorSymbol];\nexport const getCodeRefError = (ref: CodeRef) => ref[codeRefErrorSymbol];\nexport const setCodeRefError = (ref: CodeRef, e: any) => {\n  ref[codeRefErrorSymbol] = e;\n  return ref;\n};\n\n/**\n * Parse the `EncodedCodeRef` value into `[moduleName, exportName]` tuple.\n *\n * Returns an empty array if the value doesn't match the expected format.\n */\nexport const parseEncodedCodeRefValue = (value: string): [string, string] | [] => {\n  const match = value.match(/^([^.]+)(?:\\.(.+)){0,1}$/);\n  return match ? [match[1], match[2] || 'default'] : [];\n};\n\n/**\n * Returns the object referenced by the `EncodedCodeRef`.\n *\n * If an error occurs, calls `errorCallback` and returns `null`.\n *\n * _Does not throw errors by design._\n */\nexport const loadReferencedObject = async <TExport = any>(\n  ref: EncodedCodeRef,\n  entryModule: RemoteEntryModule,\n  pluginID: string,\n  errorCallback: VoidFunction,\n): Promise<TExport> => {\n  const [moduleName, exportName] = parseEncodedCodeRefValue(ref.$codeRef);\n  let requestedModule: {};\n\n  if (!moduleName) {\n    console.error(`Malformed code reference '${ref.$codeRef}' of plugin ${pluginID}`);\n    errorCallback();\n    return null;\n  }\n\n  try {\n    const moduleFactory = await entryModule.get(moduleName);\n    requestedModule = moduleFactory();\n  } catch (error) {\n    console.error(`Failed to load module '${moduleName}' of plugin ${pluginID}`, error);\n    errorCallback();\n    return null;\n  }\n\n  if (!requestedModule[exportName]) {\n    console.error(`Missing module export '${moduleName}.${exportName}' of plugin ${pluginID}`);\n    errorCallback();\n    return null;\n  }\n\n  return requestedModule[exportName];\n};\n\n/**\n * Returns new `extensions` array, resolving `EncodedCodeRef` values into `CodeRef` functions.\n *\n * _Does not execute `CodeRef` functions to load the referenced objects._\n */\nexport const resolveEncodedCodeRefs = (\n  extensions: Extension[],\n  entryModule: RemoteEntryModule,\n  pluginID: string,\n  errorCallback: VoidFunction,\n): Extension[] =>\n  _.cloneDeep(extensions).map((e) => {\n    deepForOwn<EncodedCodeRef>(e.properties, isEncodedCodeRef, (ref, key, obj) => {\n      const loader = applyCodeRefSymbol(async () =>\n        loadReferencedObject(ref, entryModule, pluginID, errorCallback),\n      );\n      obj[key] = Object.defineProperty(loader, 'name', { value: `${pluginID}-${ref.$codeRef}` });\n    });\n\n    return e;\n  });\n\n/**\n * Returns an extension with its `CodeRef` properties replaced with referenced objects.\n */\nexport const resolveExtension = async <\n  E extends Extension<P>,\n  P = ExtensionProperties<E>,\n  R = UpdateExtensionProperties<E, ResolvedCodeRefProperties<P>, P>\n>(\n  extension: E,\n): Promise<R> => {\n  const valueResolutions: Promise<void>[] = [];\n\n  deepForOwn<CodeRef>(extension.properties, isExecutableCodeRef, (ref, key, obj) => {\n    if (isCodeRefError(ref)) {\n      throw getCodeRefError(ref);\n    }\n    valueResolutions.push(\n      ref()\n        .then((resolvedValue) => {\n          obj[key] = resolvedValue;\n        })\n        .catch((e) => {\n          setCodeRefError(ref, e ?? true);\n          return e;\n        }),\n    );\n  });\n\n  await settleAllPromises(valueResolutions);\n\n  return (extension as unknown) as R;\n};\n","import { RouteComponentProps } from 'react-router';\nimport { ExtensionK8sGroupKindModel, ExtensionK8sModel } from '../api/common-types';\nimport { Extension, ExtensionDeclaration, CodeRef } from '../types';\n\ntype ResourcePageProperties = {\n  /** The model for which this resource page links to. */\n  model: ExtensionK8sGroupKindModel;\n  /** The component to be rendered when the route matches. */\n  component: CodeRef<\n    React.ComponentType<{\n      match: RouteComponentProps['match'];\n      /** The namespace for which this resource page links to. */\n      namespace: string;\n      /** The model for which this resource page links to. */\n      model: ExtensionK8sModel;\n    }>\n  >;\n};\n\ntype RoutePageProperties = {\n  /** The perspective to which this page belongs to. If not specified, contributes to all perspectives. */\n  perspective?: string;\n  /** The component to be rendered when the route matches. */\n  component: CodeRef<React.ComponentType<RouteComponentProps>>;\n  /** Valid URL path or array of paths that `path-to-regexp@^1.7.0` understands. */\n  path: string | string[];\n  /** When true, will only match if the path matches the `location.pathname` exactly. */\n  exact?: boolean;\n  /** Option to add custom className to wrapper component */\n  className?: string;\n};\n\n/** Adds new page to Console router. */\nexport type RoutePage = ExtensionDeclaration<'console.page/route', RoutePageProperties>;\n\n/** Adds new resource list page to Console router. */\nexport type ResourceListPage = ExtensionDeclaration<\n  'console.page/resource/list',\n  ResourcePageProperties & {}\n>;\n\n/** Adds new resource details page to Console router. */\nexport type ResourceDetailsPage = ExtensionDeclaration<\n  'console.page/resource/details',\n  ResourcePageProperties & {}\n>;\n\n/** Adds new resource tab page to Console router. */\nexport type ResourceTabPage = ExtensionDeclaration<\n  'console.page/resource/tab',\n  Omit<ResourcePageProperties, 'component'> & {\n    /** The component to be rendered when the route matches. */\n    component: CodeRef<React.ComponentType<RouteComponentProps>>;\n    /** The name of the tab. */\n    name: string;\n    /** The optional href for the tab link. If not provided, the first `path` is used. */\n    href?: string;\n    /** When true, will only match if the path matches the `location.pathname` exactly. */\n    exact?: boolean;\n  }\n>;\n\n/** Adds new standalone page (rendered outside the common page layout) to Console router. */\nexport type StandaloneRoutePage = ExtensionDeclaration<\n  'console.page/route/standalone',\n  Omit<RoutePageProperties, 'perspective'>\n>;\n\n// Type guards\n\nexport const isRoutePage = (e: Extension): e is RoutePage => e.type === 'console.page/route';\n\nexport const isStandaloneRoutePage = (e: Extension): e is StandaloneRoutePage =>\n  e.type === 'console.page/route/standalone';\n\nexport const isResourceListPage = (e: Extension): e is ResourceListPage =>\n  e.type === 'console.page/resource/list';\n\nexport const isResourceDetailsPage = (e: Extension): e is ResourceDetailsPage =>\n  e.type === 'console.page/resource/details';\n\nexport const isResourceTabPage = (e: Extension): e is ResourceTabPage =>\n  e.type === 'console.page/resource/tab';\n","import { ButtonProps } from '@patternfly/react-core';\nimport { TableGridBreakpoint, OnSelect, SortByDirection, ICell } from '@patternfly/react-table';\nimport { RouteComponentProps } from 'react-router';\nimport {\n  ExtensionK8sGroupKindModel,\n  K8sModel,\n  PrometheusLabels,\n  PrometheusValue,\n  ResolvedExtension,\n  Selector,\n} from '../api/common-types';\nimport { Extension, ExtensionTypeGuard } from '../types';\n\nexport type OwnerReference = {\n  name: string;\n  kind: string;\n  uid: string;\n  apiVersion: string;\n  controller?: boolean;\n  blockOwnerDeletion?: boolean;\n};\n\nexport type ObjectReference = {\n  kind?: string;\n  namespace?: string;\n  name?: string;\n  uid?: string;\n  apiVersion?: string;\n  resourceVersion?: string;\n  fieldPath?: string;\n};\n\nexport type ObjectMetadata = {\n  annotations?: { [key: string]: string };\n  clusterName?: string;\n  creationTimestamp?: string;\n  deletionGracePeriodSeconds?: number;\n  deletionTimestamp?: string;\n  finalizers?: string[];\n  generateName?: string;\n  generation?: number;\n  labels?: { [key: string]: string };\n  managedFields?: any[];\n  name?: string;\n  namespace?: string;\n  ownerReferences?: OwnerReference[];\n  resourceVersion?: string;\n  uid?: string;\n};\n\n// Properties common to (almost) all Kubernetes resources.\nexport type K8sResourceCommon = {\n  apiVersion?: string;\n  kind?: string;\n  metadata?: ObjectMetadata;\n};\n\nexport type K8sVerb =\n  | 'create'\n  | 'get'\n  | 'list'\n  | 'update'\n  | 'patch'\n  | 'delete'\n  | 'deletecollection'\n  | 'watch';\n\nexport type AccessReviewResourceAttributes = {\n  group?: string;\n  resource?: string;\n  subresource?: string;\n  verb?: K8sVerb;\n  name?: string;\n  namespace?: string;\n};\n\n/**\n * @deprecated Use K8sGroupVersionKind type instead. Support for type K8sResourceKindReference will be removed in a future release.\n * @see K8sGroupVersionKind\n * GroupVersionKind unambiguously identifies a kind.\n * https://godoc.org/k8s.io/apimachinery/pkg/runtime/schema#GroupVersionKind\n * TODO: Change this to a regex-type if it ever becomes a thing (https://github.com/Microsoft/TypeScript/issues/6579)\n */\nexport type GroupVersionKind = string;\n\n/**\n * The canonical, unique identifier for a Kubernetes resource type.\n * Maintains backwards-compatibility with references using the `kind` string field.\n */\nexport type K8sResourceKindReference = GroupVersionKind | string;\n\nexport type K8sGroupVersionKind = { group?: string; version: string; kind: string };\n\nenum InventoryStatusGroup {\n  WARN = 'WARN',\n  ERROR = 'ERROR',\n  PROGRESS = 'PROGRESS',\n  NOT_MAPPED = 'NOT_MAPPED',\n  UNKNOWN = 'UNKNOWN',\n}\n\ntype StatusGroup = {\n  [key in InventoryStatusGroup | string]: {\n    filterType?: string;\n    statusIDs: string[];\n    count: number;\n  };\n};\n\nexport type StatusGroupMapper<\n  T extends K8sResourceCommon = K8sResourceCommon,\n  R extends { [key: string]: K8sResourceCommon[] } = { [key: string]: K8sResourceCommon[] }\n> = (resources: T[], additionalResources?: R) => StatusGroup;\n\nexport enum HealthState {\n  OK = 'OK',\n  ERROR = 'ERROR',\n  WARNING = 'WARNING',\n  LOADING = 'LOADING',\n  UNKNOWN = 'UNKNOWN',\n  UPDATING = 'UPDATING',\n  PROGRESS = 'PROGRESS',\n  UPGRADABLE = 'UPGRADABLE',\n  NOT_AVAILABLE = 'NOT_AVAILABLE',\n}\n\n// Only covers range and instant vector responses for now.\nexport type PrometheusResult = {\n  metric: PrometheusLabels;\n  values?: PrometheusValue[];\n  value?: PrometheusValue;\n};\n\nexport type PrometheusData = {\n  resultType: 'matrix' | 'vector' | 'scalar' | 'string';\n  result: PrometheusResult[];\n};\n\nexport type PrometheusResponse = {\n  status: string;\n  data: PrometheusData;\n  errorType?: string;\n  error?: string;\n  warnings?: string[];\n};\n\nexport type WatchK8sResource = {\n  /** @deprecated Use groupVersionKind instead. The kind property will be removed in a future release. */\n  kind?: K8sResourceKindReference;\n  groupVersionKind?: K8sGroupVersionKind;\n  name?: string;\n  namespace?: string;\n  isList?: boolean;\n  selector?: Selector;\n  namespaced?: boolean;\n  limit?: number;\n  fieldSelector?: string;\n  optional?: boolean;\n};\n\nexport type ResourcesObject = { [key: string]: K8sResourceCommon | K8sResourceCommon[] };\n\nexport type WatchK8sResultsObject<R extends K8sResourceCommon | K8sResourceCommon[]> = {\n  data: R;\n  loaded: boolean;\n  loadError: any;\n};\n\nexport type WatchK8sResults<R extends ResourcesObject> = {\n  [k in keyof R]: WatchK8sResultsObject<R[k]>;\n};\n\nexport type WatchK8sResources<R extends ResourcesObject> = {\n  [k in keyof R]: WatchK8sResource;\n};\n\nexport type WatchK8sResourcesGeneric = {\n  [key: string]: {\n    model?: ExtensionK8sGroupKindModel;\n    opts?: Partial<WatchK8sResource>;\n  };\n};\n\nexport type FirehoseResource = {\n  kind: K8sResourceKindReference;\n  name?: string;\n  namespace?: string;\n  isList?: boolean;\n  selector?: Selector;\n  prop: string;\n  namespaced?: boolean;\n  optional?: boolean;\n  limit?: number;\n  fieldSelector?: string;\n};\n\nexport type FirehoseResult<\n  R extends K8sResourceCommon | K8sResourceCommon[] = K8sResourceCommon[]\n> = {\n  loaded: boolean;\n  loadError: string;\n  optional?: boolean;\n  data: R;\n  kind?: string;\n};\n\nexport type FirehoseResourcesResult = {\n  [key: string]: FirehoseResult<K8sResourceCommon | K8sResourceCommon[]>;\n};\n\nexport type WatchK8sResult<R extends K8sResourceCommon | K8sResourceCommon[]> = [R, boolean, any];\n\nexport type UseK8sWatchResource = <R extends K8sResourceCommon | K8sResourceCommon[]>(\n  initResource: WatchK8sResource | null,\n) => WatchK8sResult<R>;\n\nexport type UseK8sWatchResources = <R extends ResourcesObject>(\n  initResources: WatchK8sResources<R>,\n) => WatchK8sResults<R>;\n\nexport type UseResolvedExtensions = <E extends Extension>(\n  ...typeGuards: ExtensionTypeGuard<E>[]\n) => [ResolvedExtension<E>[], boolean, any[]];\n\nexport type ConsoleFetch = (\n  url: string,\n  options?: RequestInit,\n  timeout?: number,\n) => Promise<Response>;\n\nexport type ConsoleFetchJSON<T = any> = {\n  (url: string, method?: string, options?: RequestInit, timeout?: number): Promise<T>;\n  delete(url: string, json?: any, options?: RequestInit, timeout?: number): Promise<T>;\n  post(url: string, json: any, options?: RequestInit, timeout?: number): Promise<T>;\n  put(url: string, json: any, options?: RequestInit, timeout?: number): Promise<T>;\n  patch(url: string, json: any, options?: RequestInit, timeout?: number): Promise<T>;\n};\n\nexport type ConsoleFetchText = (...args: Parameters<ConsoleFetch>) => Promise<string>;\n\n/* Horizontal Nav Types */\nexport type NavPage = {\n  href?: string;\n  path?: string;\n  name: string;\n  component: React.ComponentType<RouteComponentProps>;\n};\n\nexport type HorizontalNavProps = {\n  resource?: K8sResourceCommon;\n  pages: NavPage[];\n};\n\nexport type TableColumn<D> = ICell & {\n  title: string;\n  id: string;\n  additional?: boolean;\n  sort?: ((data: D[], sortDirection: SortByDirection) => D[]) | string;\n};\n\nexport type RowProps<D, R extends any = {}> = {\n  obj: D;\n  rowData: R;\n  activeColumnIDs: Set<string>;\n};\n\ntype VirtualizedTableProps<D, R extends any = {}> = {\n  data: D[];\n  unfilteredData: D[];\n  loaded: boolean;\n  loadError: any;\n  columns: TableColumn<D>[];\n  Row: React.ComponentType<RowProps<D, R>>;\n  NoDataEmptyMsg?: React.ComponentType<{}>;\n  EmptyMsg?: React.ComponentType<{}>;\n  scrollNode?: () => HTMLElement;\n  onSelect?: OnSelect;\n  label?: string;\n  'aria-label'?: string;\n  gridBreakPoint?: TableGridBreakpoint;\n  rowData?: R;\n};\n\nexport type VirtualizedTableFC = <D, R extends any = {}>(\n  props: VirtualizedTableProps<D, R>,\n) => JSX.Element;\n\nexport type TableDataProps = {\n  id: string;\n  activeColumnIDs: Set<string>;\n  className?: string;\n};\n\nexport type UseActiveColumns = <D = any>({\n  columns,\n  showNamespaceOverride,\n  columnManagementID,\n}: {\n  columns: TableColumn<D>[];\n  showNamespaceOverride: boolean;\n  columnManagementID: string;\n}) => [TableColumn<D>[], boolean];\n\nexport type ListPageHeaderProps = {\n  title: string;\n  helpText?: React.ReactNode;\n  badge?: React.ReactNode;\n};\n\nexport type CreateWithPermissionsProps = {\n  createAccessReview?: {\n    groupVersionKind: GroupVersionKind;\n    namespace?: string;\n  };\n};\n\nexport type ListPageCreateProps = CreateWithPermissionsProps & {\n  groupVersionKind: GroupVersionKind;\n};\n\nexport type ListPageCreateLinkProps = CreateWithPermissionsProps & {\n  to: string;\n};\n\nexport type ListPageCreateButtonProps = CreateWithPermissionsProps & ButtonProps;\n\nexport type ListPageCreateDropdownProps = CreateWithPermissionsProps & {\n  items: {\n    [key: string]: React.ReactNode;\n  };\n  onClick: (item: string) => void;\n};\n\nexport type RowFilterItem = {\n  id: string;\n  title: string;\n  hideIfEmpty?: string;\n};\n\nexport type FilterValue = {\n  selected?: string[];\n  all?: string[];\n};\n\ntype RowFilterBase<R> = {\n  filterGroupName: string;\n  type: string;\n  items: RowFilterItem[];\n  filter: (input: FilterValue, obj: R) => boolean;\n  defaultSelected?: string[];\n};\n\nexport type RowMatchFilter<R = any> = RowFilterBase<R> & {\n  isMatch: (obj: R, id: string) => boolean;\n};\n\nexport type RowReducerFilter<R = any> = RowFilterBase<R> & {\n  reducer: (obj: R) => React.ReactText;\n};\n\nexport type RowFilter<R = any> = RowMatchFilter<R> | RowReducerFilter<R>;\n\nexport type ColumnLayout = {\n  id: string;\n  columns: ManagedColumn[];\n  selectedColumns: Set<string>;\n  showNamespaceOverride?: boolean;\n  type: string;\n};\n\nexport type ManagedColumn = {\n  id: string;\n  title: string;\n  additional?: boolean;\n};\n\nexport type OnFilterChange = (type: string, value: FilterValue) => void;\n\nexport type ListPageFilterProps<D = any> = {\n  data: D;\n  loaded: boolean;\n  rowFilters?: RowFilter[];\n  nameFilterPlaceholder?: string;\n  labelFilterPlaceholder?: string;\n  hideNameLabelFilters?: boolean;\n  hideLabelFilter?: boolean;\n  columnLayout?: ColumnLayout;\n  onFilterChange: OnFilterChange;\n  hideColumnManagement?: boolean;\n};\n\nexport type UseListPageFilter = <D, R>(\n  data: D[],\n  rowFilters?: RowFilter<R>[],\n  staticFilters?: { [key: string]: FilterValue },\n) => [D[], D[], OnFilterChange];\n\nexport type ResourceLinkProps = {\n  /** @deprecated Use groupVersionKind instead. The kind property will be removed in a future release. */\n  kind?: K8sResourceKindReference;\n  groupVersionKind?: K8sGroupVersionKind;\n  className?: string;\n  displayName?: string;\n  inline?: boolean;\n  linkTo?: boolean;\n  name?: string;\n  namespace?: string;\n  hideIcon?: boolean;\n  title?: string;\n  dataTest?: string;\n  onClick?: () => void;\n};\n\nexport type UseK8sModel = (\n  // Use K8sGroupVersionKind type instead of K8sResourceKindReference. Support for type K8sResourceKindReference will be removed in a future release.\n  groupVersionKind?: K8sResourceKindReference | K8sGroupVersionKind,\n) => [K8sModel, boolean];\nexport type UseK8sModels = () => [{ [key: string]: K8sModel }, boolean];\n\nexport type PerspectiveType = string;\n\nexport type UseActivePerspective = () => [\n  PerspectiveType,\n  React.Dispatch<React.SetStateAction<PerspectiveType>>,\n];\n\nexport type QueryParams = {\n  watch?: string;\n  labelSelector?: string;\n  fieldSelector?: string;\n  resourceVersion?: string;\n  [key: string]: string;\n};\n\nexport type Patch = {\n  op: string;\n  path: string;\n  value?: any;\n};\n\nexport type Cause = {\n  field: string;\n  message: string;\n  reason: string;\n};\n\nexport type Status = {\n  apiVersion: 'v1';\n  kind: 'Status';\n  details: {\n    causes: Cause[];\n    group: string;\n    kind: string;\n  };\n  message: string;\n  metadata: any;\n  reason: string;\n  status: string;\n};\n","import * as React from 'react';\nimport { JSONSchema7Type } from 'json-schema';\nimport { Extension, ExtensionDeclaration, CodeRef } from '../types';\n\nexport enum UserPreferenceFieldType {\n  dropdown = 'dropdown',\n  checkbox = 'checkbox',\n  custom = 'custom',\n}\n\nexport type UserPreferenceDropdownField = {\n  type: UserPreferenceFieldType.dropdown;\n  userSettingsKey: string;\n  defaultValue?: string;\n  options: {\n    value: string;\n    label: string;\n  }[];\n};\n\nexport type UserPreferenceCheckboxFieldValue = string | number | boolean;\n\nexport type UserPreferenceCheckboxField = {\n  type: UserPreferenceFieldType.checkbox;\n  userSettingsKey: string;\n  label: string;\n  trueValue: UserPreferenceCheckboxFieldValue;\n  falseValue: UserPreferenceCheckboxFieldValue;\n  defaultValue?: UserPreferenceCheckboxFieldValue;\n};\n\nexport type UserPreferenceCustomField = {\n  type: UserPreferenceFieldType.custom;\n  component: CodeRef<React.ComponentType>;\n  props?: { [key: string]: JSONSchema7Type };\n};\n\nexport type UserPreferenceField =\n  | UserPreferenceDropdownField\n  | UserPreferenceCheckboxField\n  | UserPreferenceCustomField;\n\nexport type UserPreferenceGroup = ExtensionDeclaration<\n  'console.user-preference/group',\n  {\n    /** ID used to identify the user preference group. */\n    id: string;\n    /** The label of the user preference group */\n    label: string;\n    /** ID of user preference group before which this group should be placed */\n    insertBefore?: string;\n    /** ID of user preference group after which this group should be placed */\n    insertAfter?: string;\n  }\n>;\n\nexport type UserPreferenceItem = ExtensionDeclaration<\n  'console.user-preference/item',\n  {\n    /** ID used to identify the user preference item and referenced in insertAfter and insertBefore to define the item order. */\n    id: string;\n    /** IDs used to identify the user preference groups the item would belong to. */\n    groupId?: string;\n    /** The label of the user preference */\n    label: string;\n    /** The description of the user preference. */\n    description: string;\n    /** The input field options used to render the values to set the user preference. */\n    field: UserPreferenceField;\n    /** ID of user preference item before which this item should be placed */\n    insertBefore?: string;\n    /** ID of user preference item after which this item should be placed */\n    insertAfter?: string;\n  }\n>;\n\n// Type guards\n\nexport const isUserPreferenceItem = (e: Extension): e is UserPreferenceItem => {\n  return e.type === 'console.user-preference/item';\n};\n\nexport const isUserPreferenceGroup = (e: Extension): e is UserPreferenceGroup => {\n  return e.type === 'console.user-preference/group';\n};\n","import * as React from 'react';\nimport { PerspectiveType } from '../extensions';\n\nexport type PerspectiveContextType = {\n  activePerspective?: PerspectiveType;\n  setActivePerspective?: React.Dispatch<React.SetStateAction<PerspectiveType>>;\n};\n\nexport const PerspectiveContext = React.createContext<PerspectiveContextType>({});\n","import * as React from 'react';\nimport { matchPath } from 'react-router';\nimport { isRoutePage as isDynamicRoutePage, RoutePage as DynamicRoutePage } from '@console/dynamic-plugin-sdk';\nimport { useExtensions } from '@openshift/dynamic-plugin-sdk';\nimport { Bullseye, Spinner } from '@patternfly/react-core';\nimport { ErrorState } from '@redhat-cloud-services/frontend-components/ErrorState';\nimport camelCase from 'lodash/camelCase';\n\nconst Loader = () => (\n  <Bullseye>\n    <Spinner />\n  </Bullseye>\n);\n\ntype DynamicRouteProps = {\n  location?: Location;\n};\n\ntype RoutePage = {\n  path: string;\n  exact?: boolean;\n};\n\nconst checkPath = (pathname, { path, exact }: RoutePage) => {\n  const [, section] = pathname.split('/');\n  return matchPath(pathname, { path, exact }) || matchPath(pathname, { path: `/${section}${path}`, exact });\n};\nconst DynamicRoute: React.FC<DynamicRouteProps> = ({ location }) => {\n  const [Component, setComponent] = React.useState<React.ExoticComponent<any>>(React.Fragment);\n  const [currClassName, setCurrClassName] = React.useState<string>(null);\n  // TODO: This seems to get executed when the tree fails to have PluginStoreProvider and then explodes\n  const dynamicRoutePages = useExtensions<DynamicRoutePage>(isDynamicRoutePage);\n  React.useEffect(() => {\n    if (location) {\n      const { properties: currRoute, pluginName } =\n        dynamicRoutePages.find(({ properties }) => {\n          if (Array.isArray(properties.path)) {\n            return properties.path.some((path) => checkPath(location.pathname, { ...properties, path }));\n          }\n          return checkPath(location.pathname, properties as RoutePage);\n        }) || {};\n      if (currRoute) {\n        setCurrClassName(camelCase(pluginName));\n        setComponent(() =>\n          React.lazy(async () => {\n            try {\n              return {\n                default: (await currRoute.component()) || Loader,\n              };\n            } catch (e) {\n              return {\n                default: () => (\n                  <Bullseye>\n                    <ErrorState errorTitle={`There was an error while loading ${pluginName} plugin.`} />\n                  </Bullseye>\n                ),\n              };\n            }\n          }),\n        );\n      }\n    }\n  }, [location, dynamicRoutePages]);\n\n  return (\n    <section className={currClassName || ''}>\n      {Component ? (\n        <React.Suspense fallback={null}>\n          <Component />\n        </React.Suspense>\n      ) : (\n        <Loader />\n      )}\n    </section>\n  );\n};\n\nexport default DynamicRoute;\n"],"names":["Operator","BadgeType","Symbol","isRoutePage","e","type","InventoryStatusGroup","HealthState","UserPreferenceFieldType","Loader","Bullseye","Spinner","checkPath","pathname","path","exact","section","split","matchPath","location","Component","setComponent","currClassName","setCurrClassName","dynamicRoutePages","useExtensions","properties","currRoute","pluginName","find","Array","isArray","some","default","component","ErrorState","errorTitle","className","fallback"],"sourceRoot":""}